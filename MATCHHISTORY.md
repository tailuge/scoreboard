# Match History Replay Badge Plan

## Objective
Add a small blue 'replay' badge to the Match History list for games that have associated replay data. Clicking the badge should redirect the user to the game replay viewer.

## Analysis
- **Data Source**: `MatchResult` has a `hasReplay` boolean field.
- **Data Retrieval**: `MatchResultService` retrieves the raw replay blob using `getMatchReplay(id)`.
- **Viewer URL**: The external viewer is located at `https://tailuge.github.io/billiards/dist/`. The replay blob is appended to this URL.
- **Current State**: `src/pages/api/match-replay.ts` currently returns the raw text of the replay data. It needs to be updated to redirect to the viewer instead, mimicking the behavior of the `Shortener` service.

## Implementation Steps

### 1. Backend Changes (`src/pages/api/match-replay.ts`) (Completed)
Modify the endpoint to redirect to the viewer instead of returning the raw data.
- **Action**: Update the handler to:
  1. Retrieve `replayData` using `MatchResultService.getMatchReplay(id)`.
  2. If found, construct the redirect URL: `https://tailuge.github.io/billiards/dist/` + `replayData`.
  3. Return `Response.redirect(url)`.
  4. If not found, return a 404 response (or redirect to a generic Not Found page if preferred, but 404 is standard for APIs).
- **Note**: This changes the API contract from returning data to returning a redirect. This is intended as the badge is a direct link for the user.

### 2. Frontend Changes (`src/components/MatchResultCard.tsx`) (Completed)
Add the visual badge to the match card.
- **Action**:
  - In `MatchResultCardComponent`, check if `result.hasReplay` is true.
  - If true, render a "REPLAY" badge.
  - **Link Destination**: `/api/match-replay?id=${result.id}`.
  - **Styling**:
    - Blue background (`bg-blue-600`), white text (`text-white`).
    - Small text (`text-[10px]` or `text-xs`), rounded (`rounded`), padding (`px-1.5 py-0.5`).
    - Place it near the timestamp or scores.

### 3. Test Updates (`src/tests/api.match-replay.test.ts`) (Completed)
Update the tests to reflect the new redirect behavior.
- **Action**:
  - Modify "should return replay data on GET request" to "should redirect to viewer on GET request".
  - Verify that the response status is 307 (Temporary Redirect) or 302.
  - Verify the `Location` header contains the correct viewer URL with the blob.

## Verification
1.  **Run Tests**: Execute `yarn jest src/tests/api.match-replay.test.ts` to ensure the API behaves as expected.
2.  **Manual Check**:
    -   Start the dev server.
    -   Ensure a match with replay data exists (or seed one).
    -   Go to the Lobby.
    -   Click the "REPLAY" badge.
    -   Verify redirection to `tailuge.github.io`.

## Future Work: Live Badge

The goal is to show a red 'LIVE' badge for currently active games in the lobby, allowing users to click and spectate.

### Backend Capabilities
-   **Active Tables**: The system already tracks active tables in Redis. `TableService.getTables()` retrieves this list.
-   **Spectator API**: The endpoint `PUT /api/tables/[tableId]/spectate` allows a user to register as a spectator. This logic is handled by `TableService.spectateTable`.
-   **Spectator URL**: The `GameUrl.create()` utility generates the correct URL for the game client in spectator mode. It accepts `isSpectator: true` and includes the `tableId` and `ruleType`.

### Proposed Implementation
1.  **Lobby UI**:
    -   In `MatchHistoryList` (or a new component for active games), fetch the list of active tables using `TableService` (or an API wrapper like `/api/tables`).
    -   For each active table, display a "LIVE" badge.
2.  **Interaction**:
    -   Clicking the "LIVE" badge should trigger the existing `handleSpectate` logic seen in `table.tsx` or `Lobby.tsx`.
    -   This involves calling the spectate API (if needed for tracking) and then opening the URL generated by `GameUrl.create()` in an iframe or new window.
3.  **Real-time Updates**:
    -   Use `nchan` or polling (existing pattern) to keep the list of active tables fresh.
    -   The `OnlineCount` component already uses some form of status checking; this could be extended.
